#!/usr/bin/env python

# fits2comp
# Create color composite images from FITS files.
# Written by Sebastiaan L. Zoutendijk, 2014-2021.
# Based on formulae from Lupton R., Blanton M.R., Fekete G., Hogg D.W., O'Mullane W., Szalay A., Wherry N., 2004, PASP, 116, 133.

import argparse
from astropy.coordinates import Angle, SkyCoord
from astropy.io import fits
from astropy.table import Table
from astropy.wcs import WCS
import numpy as np
from PIL import Image, ImageDraw, ImageFont, PngImagePlugin


def mapping(value, cutoff, softening):
    mapped = scaling(value.astype(float), softening) / \
        scaling(cutoff, softening)
    mapped[value < 0] = 0
    mapped[value > cutoff] = 1
    return mapped


def scaling(value, softening):
    scaled = np.arcsinh(value/softening)
    return scaled


parser = argparse.ArgumentParser(
    description='Create color composite images from FITS files',
    epilog="""If only RED is given, GREEN and BLUE are taken equal to RED,
           which produces a grayscale image.  If RED and GREEN are given,
           BLUE is extrapolated from them.""")
parser.add_argument('-b', '--background', default=0, type=float,
                    help='background pixel value in FITS')
parser.add_argument('-C', '--crop', metavar=('LEFT', 'UP', 'RIGHT', 'DOWN'),
                    nargs=4, type=int, help='cropping bounding box')
parser.add_argument('-c', '--cutoff', default=65535, type=float,
                    help='cut-off pixel value in FITS')
parser.add_argument('-l', '--source-list', metavar='FILENAME', type=str,
                    help='indicate source positions from file')
parser.add_argument('-o', '--offset', metavar=('X', 'Y'), nargs=2, default=(0, 0), type=float,
                    help='X and Y offset of source positions, in pixels')
parser.add_argument('-R', '--ruler', metavar='LABEL', type=str,
                    help='add 1 arcmin ruler with label')
parser.add_argument('-r', '--rotate', metavar='DEGREES', default=0, type=float,
                    help='rotate image by DEGREES degrees')
parser.add_argument('-S', '--stretch', default=0, type=float,
                    help='stretch around background with this amplitude')
parser.add_argument('-s', '--softening', default=1, type=float,
                    help='softening parameter')
parser.add_argument('red', metavar='RED', help='red channel FITS file')
parser.add_argument('green', metavar='GREEN', nargs='?',
                    help='green channel FITS file')
parser.add_argument('blue', metavar='BLUE', nargs='?',
                    help='blue channel FITS file')
parser.add_argument('composite', metavar='COMPOSITE',
                    help='output composite image')
sys_args = parser.parse_args()

red_file = fits.open(sys_args.red)
mask = np.isfinite(red_file[1].data)
red = np.nan_to_num(red_file[1].data) - sys_args.background
red_file.close()
if sys_args.green is not None:
    green_file = fits.open(sys_args.green)
    mask &= np.isfinite(green_file[1].data)
    green = np.nan_to_num(green_file[1].data) - sys_args.background
    green_file.close()
    if sys_args.blue is not None:
        blue_file = fits.open(sys_args.blue)
        mask &= np.isfinite(blue_file[1].data)
        blue = np.nan_to_num(blue_file[1].data) - sys_args.background
        blue_file.close()
    else:
        blue = 2 * green - red
else:
    green = red
    blue = red
average = (red+green+blue) / 3

if sys_args.stretch == 0:
    Red = np.zeros(red.shape)
    Green = np.zeros(green.shape)
    Blue = np.zeros(blue.shape)
    Red[average > 0] = red[average > 0] * mapping(average[average > 0], sys_args.cutoff, sys_args.softening) / \
        average[average > 0]
    Green[average > 0] = green[average > 0] * mapping(average[average > 0], sys_args.cutoff, sys_args.softening) / \
        average[average > 0]
    Blue[average > 0] = blue[average > 0] * mapping(average[average > 0], sys_args.cutoff, sys_args.softening) / \
        average[average > 0]
    amax = np.amax([Red, Green, Blue], axis=0)
    Red[amax > 1] = Red[amax > 1] / amax[amax > 1]
    Green[amax > 1] = Green[amax > 1] / amax[amax > 1]
    Blue[amax > 1] = Blue[amax > 1] / amax[amax > 1]
    Red[Red < 0] = 0
    Green[Green < 0] = 0
    Blue[Blue < 0] = 0
else:
    negRed = np.zeros(red.shape)
    negGreen = np.zeros(green.shape)
    negBlue = np.zeros(blue.shape)
    negRed[average < 0] = -red[average < 0] * mapping(-average[average < 0], sys_args.stretch, sys_args.softening) / \
        -average[average < 0]
    negGreen[average < 0] = -green[average < 0] * mapping(-average[average < 0], sys_args.stretch, sys_args.softening) / \
        -average[average < 0]
    negBlue[average < 0] = -blue[average < 0] * mapping(-average[average < 0], sys_args.stretch, sys_args.softening) / \
        -average[average < 0]
    amax = np.amax([negRed, negGreen, negBlue], axis=0)
    negRed[amax > 1] = negRed[amax > 1] / amax[amax > 1]
    negGreen[amax > 1] = negGreen[amax > 1] / amax[amax > 1]
    negBlue[amax > 1] = negBlue[amax > 1] / amax[amax > 1]
    negRed[negRed < 0] = 0
    negGreen[negGreen < 0] = 0
    negBlue[negBlue < 0] = 0

    posRed = np.zeros(red.shape)
    posGreen = np.zeros(green.shape)
    posBlue = np.zeros(blue.shape)
    posRed[average > 0] = +red[average > 0] * mapping(+average[average > 0], sys_args.stretch, sys_args.softening) / \
        +average[average > 0]
    posGreen[average > 0] = +green[average > 0] * mapping(+average[average > 0], sys_args.stretch, sys_args.softening) / \
        +average[average > 0]
    posBlue[average > 0] = +blue[average > 0] * mapping(+average[average > 0], sys_args.stretch, sys_args.softening) / \
        +average[average > 0]
    amax = np.amax([posRed, posGreen, posBlue], axis=0)
    posRed[amax > 1] = posRed[amax > 1] / amax[amax > 1]
    posGreen[amax > 1] = posGreen[amax > 1] / amax[amax > 1]
    posBlue[amax > 1] = posBlue[amax > 1] / amax[amax > 1]
    posRed[posRed < 0] = 0
    posGreen[posGreen < 0] = 0
    posBlue[posBlue < 0] = 0

    Red = (-negRed+posRed) / 2. + 0.5
    Green = (-negGreen+posGreen) / 2. + 0.5
    Blue = (-negBlue+posBlue) / 2. + 0.5

Red_image = Image.fromarray(np.around(255*Red[::-1,:]).astype('uint8'))
Green_image = Image.fromarray(np.around(255*Green[::-1,:]).astype('uint8'))
Blue_image = Image.fromarray(np.around(255*Blue[::-1,:]).astype('uint8'))
Alpha_image = Image.fromarray(255*mask[::-1,:].astype('uint8'))
image = Image.merge('RGBA', (Red_image, Green_image, Blue_image, Alpha_image))
image = image.rotate(sys_args.rotate)

wcs = WCS(red_file[1].header)

if sys_args.source_list is not None:
    draw = ImageDraw.Draw(image)
    #cat = Table.read(sys_args.source_list).as_array()
    cat = Table.read(sys_args.source_list)
    #cat = cat[cat["Field"] != 6]
    #cat = cat[cat["f_Member"] == 1]
    #cat = cat[np.isnan(cat["L_Cluster"])]
    #cat = [(np.mean(cat["RAdeg"][cat["ID"] == ID]), np.mean(cat["DEdeg"][cat["ID"] == ID])) for ID in list(set(cat["ID"]))]
    #sources = wcs.all_world2pix(cat, 0)
    sources = wcs.all_world2pix(np.array([cat["RAdeg"], cat["DEdeg"]]).transpose(), 0)

    for source in sources:
        source = np.array([source[0]+sys_args.offset[0], image.size[1]-(source[1]+sys_args.offset[1])])
        draw.ellipse((tuple(source-10), tuple(source+10)), outline="lime", width=3)

if sys_args.ruler is not None:
    image = image.crop((0, 0, image.size[0], image.size[1]+70))
    draw = ImageDraw.Draw(image)
    line_start_px = (20, 20)
    line_start_deg = SkyCoord(*wcs.all_pix2world(*line_start_px, 0), unit="deg")
    line_end_deg = line_start_deg.directional_offset_by(-np.pi/2, Angle('1arcmin'))
    line_end_px = wcs.all_world2pix(line_end_deg.ra.deg, line_end_deg.dec.deg, 0)
    draw.line(((line_start_px[0], image.size[1]-line_start_px[1]), (line_end_px[0], image.size[1]-line_end_px[1])), fill="lime", width=5)
    half_line = np.mean([line_start_px, line_end_px], axis=0)
    draw.text((half_line[0], image.size[1]-half_line[1]-5), sys_args.ruler, font=ImageFont.truetype("DejaVuSans.ttf", 24), fill="lime", anchor="md")

tags = PngImagePlugin.PngInfo()
tags.add_text('Software', 'fits2comp')
tags.add_text('--background', repr(sys_args.background))
tags.add_text('--crop', repr(sys_args.crop))
tags.add_text('--cutoff', repr(sys_args.cutoff))
tags.add_text('--offset', repr(sys_args.offset))
tags.add_text('--rotate', repr(sys_args.rotate))
tags.add_text('--ruler', repr(sys_args.ruler))
tags.add_text('--stretch', repr(sys_args.stretch))
tags.add_text('--softening', repr(sys_args.softening))
tags.add_text('--source-list', repr(sys_args.source_list))
tags.add_text('RED', repr(sys_args.red))
tags.add_text('BLUE', repr(sys_args.blue))
tags.add_text('GREEN', repr(sys_args.green))
tags.add_text('COMPOSITE', repr(sys_args.composite))

if sys_args.crop is not None:
    image = image.crop(sys_args.crop, pnginfo=tags)
image.save(sys_args.composite, pnginfo=tags)

#!/usr/bin/env python

# fits2comp
# Create color composite images from FITS files.
# Written by Sebastiaan L. Zoutendijk, 2014-2021.
# Based on formulae from Lupton R., Blanton M.R., Fekete G., Hogg D.W., O'Mullane W., Szalay A., Wherry N., 2004, PASP, 116, 133.

import argparse
from astropy.coordinates import Angle, SkyCoord
from astropy.io import fits
from astropy.table import Table
from astropy.wcs import WCS
import numpy as np
from PIL import Image, ImageDraw, ImageFont, PngImagePlugin


def mapping(value, cutoff, softening):
    mapped = scaling(value.astype(float), softening) / \
        scaling(cutoff, softening)
    mapped[value < 0] = 0
    mapped[value > cutoff] = 1
    return mapped


def scaling(value, softening):
    scaled = np.arcsinh(value/softening)
    return scaled


parser = argparse.ArgumentParser(
    description='Create color composite images from FITS files',
    epilog="""If only RED is given, GREEN and BLUE are taken equal to RED,
           which produces a grayscale image.  If RED and GREEN are given,
           BLUE is extrapolated from them.""")
parser.add_argument('-A', '--no-annotation-area', action='store_true',
                    help='draw ruler and compass in the image area')
parser.add_argument('-B', '--crop', metavar=('LEFT', 'UP', 'RIGHT', 'DOWN'),
                    nargs=4, type=int, help='cropping bounding box')
parser.add_argument('-b', '--background', default=0, type=float,
                    help='background pixel value in FITS')
parser.add_argument('-C', '--compass', action='store_true',
                    help='add compass indicating north and east')
parser.add_argument('-c', '--cutoff', default=65535, type=float,
                    help='cut-off pixel value in FITS')
parser.add_argument('-l', '--source-list', metavar='FILENAME', type=str,
                    help='indicate source positions from file')
parser.add_argument('-n', '--name', metavar='NAME', type=str,
                    help='add target name')
parser.add_argument('-o', '--offset', metavar=('X', 'Y'), nargs=2, default=(0, 0), type=float,
                    help='X and Y offset of source positions, in pixels')
parser.add_argument('-R', '--ruler', metavar=('ANGULAR', 'PHYSICAL'), nargs=2, type=str,
                    help='add ruler of ANGULAR length, with ANGULAR and PHYSICAL labels')
parser.add_argument('-r', '--rotate', metavar='DEGREES', default=0, type=float,
                    help='rotate image by DEGREES degrees')
parser.add_argument('-S', '--stretch', default=0, type=float,
                    help='stretch around background with this amplitude')
parser.add_argument('-s', '--softening', default=1, type=float,
                    help='softening parameter')
parser.add_argument('red', metavar='RED', help='red channel FITS file')
parser.add_argument('green', metavar='GREEN', nargs='?',
                    help='green channel FITS file')
parser.add_argument('blue', metavar='BLUE', nargs='?',
                    help='blue channel FITS file')
parser.add_argument('composite', metavar='COMPOSITE',
                    help='output composite image')
sys_args = parser.parse_args()

red_file = fits.open(sys_args.red)
mask = np.isfinite(red_file[1].data)
red = np.nan_to_num(red_file[1].data) - sys_args.background
red_file.close()
if sys_args.green is not None:
    green_file = fits.open(sys_args.green)
    mask &= np.isfinite(green_file[1].data)
    green = np.nan_to_num(green_file[1].data) - sys_args.background
    green_file.close()
    if sys_args.blue is not None:
        blue_file = fits.open(sys_args.blue)
        mask &= np.isfinite(blue_file[1].data)
        blue = np.nan_to_num(blue_file[1].data) - sys_args.background
        blue_file.close()
    else:
        blue = 2 * green - red
else:
    green = red
    blue = red
average = (red+green+blue) / 3

if sys_args.stretch == 0:
    Red = np.zeros(red.shape)
    Green = np.zeros(green.shape)
    Blue = np.zeros(blue.shape)
    Red[average > 0] = red[average > 0] * mapping(average[average > 0], sys_args.cutoff, sys_args.softening) / \
        average[average > 0]
    Green[average > 0] = green[average > 0] * mapping(average[average > 0], sys_args.cutoff, sys_args.softening) / \
        average[average > 0]
    Blue[average > 0] = blue[average > 0] * mapping(average[average > 0], sys_args.cutoff, sys_args.softening) / \
        average[average > 0]
    amax = np.amax([Red, Green, Blue], axis=0)
    Red[amax > 1] = Red[amax > 1] / amax[amax > 1]
    Green[amax > 1] = Green[amax > 1] / amax[amax > 1]
    Blue[amax > 1] = Blue[amax > 1] / amax[amax > 1]
    Red[Red < 0] = 0
    Green[Green < 0] = 0
    Blue[Blue < 0] = 0
else:
    negRed = np.zeros(red.shape)
    negGreen = np.zeros(green.shape)
    negBlue = np.zeros(blue.shape)
    negRed[average < 0] = -red[average < 0] * mapping(-average[average < 0], sys_args.stretch, sys_args.softening) / \
        -average[average < 0]
    negGreen[average < 0] = -green[average < 0] * mapping(-average[average < 0], sys_args.stretch, sys_args.softening) / \
        -average[average < 0]
    negBlue[average < 0] = -blue[average < 0] * mapping(-average[average < 0], sys_args.stretch, sys_args.softening) / \
        -average[average < 0]
    amax = np.amax([negRed, negGreen, negBlue], axis=0)
    negRed[amax > 1] = negRed[amax > 1] / amax[amax > 1]
    negGreen[amax > 1] = negGreen[amax > 1] / amax[amax > 1]
    negBlue[amax > 1] = negBlue[amax > 1] / amax[amax > 1]
    negRed[negRed < 0] = 0
    negGreen[negGreen < 0] = 0
    negBlue[negBlue < 0] = 0

    posRed = np.zeros(red.shape)
    posGreen = np.zeros(green.shape)
    posBlue = np.zeros(blue.shape)
    posRed[average > 0] = +red[average > 0] * mapping(+average[average > 0], sys_args.stretch, sys_args.softening) / \
        +average[average > 0]
    posGreen[average > 0] = +green[average > 0] * mapping(+average[average > 0], sys_args.stretch, sys_args.softening) / \
        +average[average > 0]
    posBlue[average > 0] = +blue[average > 0] * mapping(+average[average > 0], sys_args.stretch, sys_args.softening) / \
        +average[average > 0]
    amax = np.amax([posRed, posGreen, posBlue], axis=0)
    posRed[amax > 1] = posRed[amax > 1] / amax[amax > 1]
    posGreen[amax > 1] = posGreen[amax > 1] / amax[amax > 1]
    posBlue[amax > 1] = posBlue[amax > 1] / amax[amax > 1]
    posRed[posRed < 0] = 0
    posGreen[posGreen < 0] = 0
    posBlue[posBlue < 0] = 0

    Red = (-negRed+posRed) / 2. + 0.5
    Green = (-negGreen+posGreen) / 2. + 0.5
    Blue = (-negBlue+posBlue) / 2. + 0.5

Red_image = Image.fromarray(np.around(255*Red[::-1,:]).astype('uint8'))
Green_image = Image.fromarray(np.around(255*Green[::-1,:]).astype('uint8'))
Blue_image = Image.fromarray(np.around(255*Blue[::-1,:]).astype('uint8'))
Alpha_image = Image.fromarray(255*mask[::-1,:].astype('uint8'))
image = Image.merge('RGBA', (Red_image, Green_image, Blue_image, Alpha_image))
image = image.rotate(sys_args.rotate)

wcs = WCS(red_file[1].header)

if sys_args.source_list is not None:
    draw = ImageDraw.Draw(image)
    cat = Table.read(sys_args.source_list)
    sources = wcs.all_world2pix(np.array([cat["RAdeg"], cat["DEdeg"]]).transpose(), 0)

    for source in sources:
        source = np.array([source[0]+sys_args.offset[0], (source[1]+sys_args.offset[1])])
        for x in range(mask.shape[1]):
            for y in range(mask.shape[0]):
                if (x-source[0])**2 + (y-source[1])**2 <= 10**2 and mask[y,x]:
                    source = np.array([source[0], image.size[1]-source[1]])
                    draw.ellipse((tuple(source-10), tuple(source+10)), outline="yellow", width=1)
                    break
            else:
                continue
            break

if (sys_args.name is not None or sys_args.ruler is not None or sys_args.compass) and not sys_args.no_annotation_area:
    image = image.crop((0, 0, image.size[0], image.size[1]+60))
    draw = ImageDraw.Draw(image)

if sys_args.ruler is not None:
    line_start_px = (0, 30)
    line_start_deg = SkyCoord(*wcs.all_pix2world(*line_start_px, 0), unit="deg")
    line_test_px = (1, 30)
    line_test_deg = SkyCoord(*wcs.all_pix2world(*line_test_px, 0), unit="deg")
    line_pos_ang = line_start_deg.position_angle(line_test_deg)
    line_end_deg = line_start_deg.directional_offset_by(line_pos_ang, Angle(sys_args.ruler[0]))
    line_end_px = wcs.all_world2pix(line_end_deg.ra.deg, line_end_deg.dec.deg, 0)
    draw.line(((line_start_px[0], image.size[1]-line_start_px[1]), (line_end_px[0], image.size[1]-line_end_px[1])), fill="black", width=5)
    half_line = np.mean([line_start_px, line_end_px], axis=0)
    draw.text((half_line[0], image.size[1]-half_line[1]-15), sys_args.ruler[0], font=ImageFont.truetype("DejaVuSans.ttf", 24), fill="black", anchor="mm")
    draw.text((half_line[0], image.size[1]-half_line[1]+15), sys_args.ruler[1], font=ImageFont.truetype("DejaVuSans.ttf", 24), fill="black", anchor="mm")
else:
    line_end_px = (0, 30)

if sys_args.compass:
    compass_start_px = (image.size[0]-30, 30)
    compass_start_deg = SkyCoord(*wcs.all_pix2world(*compass_start_px, 0), unit="deg")
    compass_north_test_deg = compass_start_deg.directional_offset_by(0, Angle('1arcsec'))
    compass_north_test_px = wcs.all_world2pix(compass_north_test_deg.ra.deg, compass_north_test_deg.dec.deg, 0)
    compass_north_xy_ang = np.arctan2(compass_north_test_px[1]-compass_start_px[1], compass_north_test_px[0]-compass_start_px[0])
    compass_north_end_px = (compass_start_px[0] + 20 * np.cos(compass_north_xy_ang), compass_start_px[1] + 20 * np.sin(compass_north_xy_ang))
    compass_north_text_px = (compass_start_px[0] + 15*np.sqrt(2) * np.cos(compass_north_xy_ang-np.pi/4), compass_start_px[1] + 15*np.sqrt(2) * np.sin(compass_north_xy_ang-np.pi/4))
    compass_east_test_deg = compass_start_deg.directional_offset_by(np.pi/2, Angle('1arcsec'))
    compass_east_test_px = wcs.all_world2pix(compass_east_test_deg.ra.deg, compass_east_test_deg.dec.deg, 0)
    compass_east_xy_ang = np.arctan2(compass_east_test_px[1]-compass_start_px[1], compass_east_test_px[0]-compass_start_px[0])
    compass_east_end_px = (compass_start_px[0] + 20 * np.cos(compass_east_xy_ang), compass_start_px[1] + 20 * np.sin(compass_east_xy_ang))
    compass_east_text_px = (compass_start_px[0] + 15*np.sqrt(2) * np.cos(compass_east_xy_ang+np.pi/4), compass_start_px[1] + 15*np.sqrt(2) * np.sin(compass_east_xy_ang+np.pi/4))
    draw.line(((compass_north_end_px[0], image.size[1]-compass_north_end_px[1]), (compass_start_px[0], image.size[1]-compass_start_px[1]), (compass_east_end_px[0], image.size[1]-compass_east_end_px[1])), fill="black", width=5)
    draw.regular_polygon(((compass_north_end_px[0], image.size[1]-compass_north_end_px[1]), 5), 3, compass_north_xy_ang*180/np.pi-90, fill="black")
    draw.regular_polygon(((compass_east_end_px[0], image.size[1]-compass_east_end_px[1]), 5), 3, compass_east_xy_ang*180/np.pi-90, fill="black")
    draw.text((compass_north_text_px[0], image.size[1]-compass_north_text_px[1]), 'N', font=ImageFont.truetype("DejaVuSans.ttf", 24), fill="black", anchor="mm")
    draw.text((compass_east_text_px[0], image.size[1]-compass_east_text_px[1]), 'E', font=ImageFont.truetype("DejaVuSans.ttf", 24), fill="black", anchor="mm")
    compass_left_px = (image.size[0]-60, 30)
else:
    compass_left_px = (image.size[0], 30)

if sys_args.name is not None:
    name_px = np.mean([line_end_px, compass_left_px], axis=0)
    draw.text((name_px[0], image.size[1]-name_px[1]), sys_args.name, font=ImageFont.truetype("DejaVuSans.ttf", 24), fill="black", anchor="mm")

tags = PngImagePlugin.PngInfo()
tags.add_text('Software', 'fits2comp')
tags.add_text('--background', repr(sys_args.background))
tags.add_text('--compass', repr(sys_args.compass))
tags.add_text('--crop', repr(sys_args.crop))
tags.add_text('--cutoff', repr(sys_args.cutoff))
tags.add_text('--name', repr(sys_args.name))
tags.add_text('--no-annotation-area', repr(sys_args.no_annotation_area))
tags.add_text('--offset', repr(sys_args.offset))
tags.add_text('--rotate', repr(sys_args.rotate))
tags.add_text('--ruler', repr(sys_args.ruler))
tags.add_text('--stretch', repr(sys_args.stretch))
tags.add_text('--softening', repr(sys_args.softening))
tags.add_text('--source-list', repr(sys_args.source_list))
tags.add_text('RED', repr(sys_args.red))
tags.add_text('BLUE', repr(sys_args.blue))
tags.add_text('GREEN', repr(sys_args.green))
tags.add_text('COMPOSITE', repr(sys_args.composite))

if sys_args.crop is not None:
    image = image.crop(sys_args.crop)
image.save(sys_args.composite, pnginfo=tags)
